# ìŠ¤íŠ¸ë¦¼ êµ¬ì¡° ë¶„ì„ ë° ANTLR ì„œë²„ ì ìš© ë°©ì•ˆ

## ğŸ“Š í˜„ì¬ ìŠ¤íŠ¸ë¦¼ êµ¬ì¡° ë¶„ì„

### 1. Backend Server ìŠ¤íŠ¸ë¦¼ êµ¬í˜„ (í˜„ì¬ ì‘ë™ ì¤‘)

#### êµ¬ì¡° ê°œìš”
```
[í”„ë¡ íŠ¸ì—”ë“œ] â†’ POST ìš”ì²­ â†’ [Backend Server] â†’ NDJSON ìŠ¤íŠ¸ë¦¼ ì‘ë‹µ â†’ [í”„ë¡ íŠ¸ì—”ë“œ]
```

#### í•µì‹¬ ì»´í¬ë„ŒíŠ¸

**`src/services/api.ts`ì˜ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ ë¡œì§:**

1. **`streamFetch()` í•¨ìˆ˜** (138-160ì¤„)
   - POST ìš”ì²­ì„ ë³´ë‚´ê³  ìŠ¤íŠ¸ë¦¼ ì‘ë‹µì„ ë°›ìŒ
   - `ReadableStream`ì˜ `getReader()`ë¡œ ìŠ¤íŠ¸ë¦¼ ì½ê¸° ì‹œì‘
   - `processStream()`ìœ¼ë¡œ ì‹¤ì œ ë°ì´í„° ì²˜ë¦¬ ìœ„ì„

2. **`processStream()` í•¨ìˆ˜** (165-186ì¤„)
   - `TextDecoder`ë¡œ ë°”ì´ë„ˆë¦¬ ë°ì´í„°ë¥¼ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜
   - ë²„í¼ì— ìŒ“ì´ë©´ì„œ ê°œí–‰(`\n`) ë‹¨ìœ„ë¡œ JSON ë¼ì¸ ë¶„ë¦¬
   - ì™„ì „í•œ JSON ë¼ì¸ë§Œ íŒŒì‹±í•˜ì—¬ ì´ë²¤íŠ¸ë¡œ ì „ë‹¬

3. **`processBuffer()` í•¨ìˆ˜** (191-206ì¤„)
   - ë²„í¼ë¥¼ ê°œí–‰ìœ¼ë¡œ ë¶„ë¦¬
   - ì™„ì „í•œ ë¼ì¸ë§Œ JSON íŒŒì‹±í•˜ì—¬ `onEvent` ì½œë°± í˜¸ì¶œ
   - ë¶ˆì™„ì „í•œ ë¼ì¸ì€ ë²„í¼ì— ë‚¨ê²¨ë‘ì–´ ë‹¤ìŒ ì²­í¬ì™€ ê²°í•©

4. **NDJSON í˜•ì‹**
   ```
   {"type": "message", "content": "Processing..."}\n
   {"type": "data", "graph": {...}}\n
   {"type": "status", "step": 1, "done": true}\n
   {"type": "complete"}\n
   ```

#### ì‚¬ìš© ì˜ˆì‹œ (Understanding/Convert)

**`src/stores/project.ts`ì—ì„œì˜ ì‚¬ìš©:**

```typescript
// Understanding (352-376ì¤„) - status ë¯¸ì‚¬ìš©
await backendApi.cypherQuery(
  understandingMeta.value,
  sessionStore.getHeaders(),
  (event) => {
    // ë©”ì‹œì§€ ì²˜ë¦¬
    if (event.content) {
      addGraphMessage(event.type === 'error' ? 'error' : 'message', event.content)
    }
    
    // ê·¸ë˜í”„ ë°ì´í„° ì²˜ë¦¬
    if (event.graph?.Nodes || event.graph?.Relationships) {
      updateGraphData(event.graph.Nodes || [], event.graph.Relationships || [])
    }
    
    // ì™„ë£Œ/ì—ëŸ¬ ì²˜ë¦¬
    if (event.type === 'complete') {
      currentStep.value = 'Understanding ì™„ë£Œ'
    }
  }
)

// Convert (405-407ì¤„) - status ì‚¬ìš© (í”„ë ˆì„ì›Œí¬ ë‹¨ê³„ ì¶”ì )
await backendApi.convert(payload, sessionStore.getHeaders(), (event) => {
  handleConvertEvent(event, classNames) // ì—¬ê¸°ì„œ status ì²˜ë¦¬
})
```

**ì¤‘ìš”**: Understandingì€ `message`, `data`, `complete`, `error`ë§Œ ì‚¬ìš©í•˜ë©°, `status`ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. `status`ëŠ” Convertì—ì„œë§Œ í”„ë ˆì„ì›Œí¬ ë‹¨ê³„ë¥¼ ì¶”ì í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤.

### 2. ANTLR Server í˜„ì¬ êµ¬ì¡° (ìŠ¤íŠ¸ë¦¼ ë¯¸ì§€ì›)

#### í˜„ì¬ êµ¬í˜„
- **`uploadFiles()`**: FormData POST â†’ ì¼ë°˜ JSON ì‘ë‹µ (`FileUploadResponse`)
- **`parse()`**: JSON POST â†’ ì¼ë°˜ JSON ì‘ë‹µ (`ParseResponse`)

#### ë¬¸ì œì 
- ìŠ¤íŠ¸ë¦¼ ë°©ì‹ì´ ì•„ë‹ˆë¯€ë¡œ ì§„í–‰ ìƒí™©ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ë³¼ ìˆ˜ ì—†ìŒ
- íŒŒì‹± ê³¼ì •ì—ì„œ ë°œìƒí•˜ëŠ” ë¡œê·¸ë‚˜ ì—ëŸ¬ë¥¼ ì¦‰ì‹œ í™•ì¸í•  ìˆ˜ ì—†ìŒ
- ì‚¬ìš©ì ê²½í—˜ì´ ì¢‹ì§€ ì•ŠìŒ (ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¤ì•¼ í•¨)

---

## ğŸ¯ ANTLR ì„œë²„ ìŠ¤íŠ¸ë¦¼ ì ìš© ë°©ì•ˆ

### ë°©ì•ˆ 1: êµ¬ì¡°ë¥¼ ë˜‘ê°™ì´ ë§ì¶”ê¸° (ê¶Œì¥ âœ…)

**ì¥ì :**
- ì½”ë“œ ì¼ê´€ì„± ìœ ì§€ (Backendì™€ ë™ì¼í•œ íŒ¨í„´)
- ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ìŠ¤íŠ¸ë¦¼ ì²˜ë¦¬ ë¡œì§ í™œìš©
- ìœ ì§€ë³´ìˆ˜ ìš©ì´
- ì‚¬ìš©ì ê²½í—˜ ì¼ê´€ì„± (ëª¨ë“  APIê°€ ìŠ¤íŠ¸ë¦¼ ë°©ì‹)

**êµ¬í˜„ ë°©ë²•:**

#### 1ë‹¨ê³„: ANTLR APIì— ìŠ¤íŠ¸ë¦¼ í•¨ìˆ˜ ì¶”ê°€

```typescript
// src/services/api.tsì˜ antlrApi ê°ì²´ì— ì¶”ê°€

export const antlrApi = {
  // ê¸°ì¡´ í•¨ìˆ˜ë“¤...
  
  /**
   * ANTLR íŒŒì‹± (ìŠ¤íŠ¸ë¦¼ ë°©ì‹)
   */
  async parseStream(
    metadata: BackendRequestMetadata,
    headers: Headers,
    onEvent: StreamCallback
  ): Promise<void> {
    await streamFetch(
      `${ANTLR_BASE_URL}/parsing`,
      metadata,
      headers,
      onEvent
    )
  },
  
  /**
   * íŒŒì¼ ì—…ë¡œë“œ (ìŠ¤íŠ¸ë¦¼ ë°©ì‹ - ì„ íƒì )
   */
  async uploadFilesStream(
    metadata: BackendRequestMetadata,
    files: File[],
    headers: Headers,
    onEvent: StreamCallback
  ): Promise<void> {
    // FormDataë¥¼ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë³´ë‚´ëŠ” ê²½ìš°ëŠ” ë³µì¡í•˜ë¯€ë¡œ
    // ì—…ë¡œë“œëŠ” ì¼ë°˜ ë°©ì‹ ìœ ì§€í•˜ê³  íŒŒì‹±ë§Œ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì „í™˜ ê¶Œì¥
    // í•„ìš”ì‹œ ë³„ë„ êµ¬í˜„
  }
}
```

#### 2ë‹¨ê³„: Storeì—ì„œ ìŠ¤íŠ¸ë¦¼ ë°©ì‹ ì‚¬ìš©

```typescript
// src/stores/project.tsì˜ parseFiles() í•¨ìˆ˜ ìˆ˜ì •

async function parseFiles() {
  isProcessing.value = true
  currentStep.value = 'íŒŒì‹± ì¤‘...'
  
  // íŒŒì‹± ë©”ì‹œì§€ë¥¼ ì €ì¥í•  ë°°ì—´ (ê·¸ë˜í”„ ë©”ì‹œì§€ì™€ ë¶„ë¦¬í•˜ê±°ë‚˜ ë³„ë„ ê´€ë¦¬)
  // ì˜ˆ: parseMessages.value = []
  
  try {
    await antlrApi.parseStream(
      understandingMeta.value,
      sessionStore.getHeaders(),
      (event) => {
        // ë©”ì‹œì§€ ì²˜ë¦¬
        if (event.content) {
          // íŒŒì‹± ë¡œê·¸ ë©”ì‹œì§€ ì¶”ê°€
          addParseMessage(event.type === 'error' ? 'error' : 'message', event.content)
        }
        
        // ì™„ë£Œ ì²˜ë¦¬
        if (event.type === 'complete') {
          currentStep.value = 'íŒŒì‹± ì™„ë£Œ'
        } else if (event.type === 'error') {
          currentStep.value = 'íŒŒì‹± ì—ëŸ¬'
        }
      }
    )
  } catch (error) {
    currentStep.value = 'íŒŒì‹± ì‹¤íŒ¨'
    throw error
  } finally {
    isProcessing.value = false
  }
}
```

#### 3ë‹¨ê³„: ANTLR ì„œë²„ êµ¬í˜„ ìš”êµ¬ì‚¬í•­

**ANTLR ì„œë²„ê°€ ì‘ë‹µí•´ì•¼ í•  NDJSON í˜•ì‹:**

Understanding ìŠ¤íŠ¸ë¦¼ê³¼ ë™ì¼í•˜ê²Œ **statusëŠ” í•„ìš” ì—†ìŠµë‹ˆë‹¤**. ë‹¨ìˆœíˆ ë©”ì‹œì§€ë§Œ ì „ì†¡:

```json
{"type": "message", "content": "íŒŒì‹± ì‹œì‘..."}
{"type": "message", "content": "íŒŒì¼ 1/10 íŒŒì‹± ì¤‘: MyClass.java"}
{"type": "message", "content": "íŒŒì¼ 2/10 íŒŒì‹± ì¤‘: AnotherClass.java"}
{"type": "message", "content": "íŒŒì‹± ì™„ë£Œ: 10ê°œ íŒŒì¼ ì²˜ë¦¬ë¨"}
{"type": "complete"}
```

**ì°¸ê³ **: `status`ëŠ” Convert ìŠ¤íŠ¸ë¦¼ì—ì„œë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤ (í”„ë ˆì„ì›Œí¬ ë‹¨ê³„ ì¶”ì ìš©). Understandingê³¼ íŒŒì‹±ì€ ë‹¨ìˆœ ë©”ì‹œì§€ë§Œ í•„ìš”í•©ë‹ˆë‹¤.

**ì—ëŸ¬ ì¼€ì´ìŠ¤:**
```json
{"type": "error", "content": "íŒŒì‹± ì‹¤íŒ¨: êµ¬ë¬¸ ì˜¤ë¥˜", "errorType": "SyntaxError", "traceId": "..."}
```

### ë°©ì•ˆ 2: í•˜ì´ë¸Œë¦¬ë“œ ë°©ì‹ (ê¶Œì¥í•˜ì§€ ì•ŠìŒ)

- ì—…ë¡œë“œëŠ” ì¼ë°˜ ë°©ì‹, íŒŒì‹±ë§Œ ìŠ¤íŠ¸ë¦¼
- ì½”ë“œ ë³µì¡ë„ ì¦ê°€
- ì¼ê´€ì„± ë¶€ì¡±

---

## ğŸ’¡ ê¶Œì¥ ì‚¬í•­

### âœ… êµ¬ì¡°ë¥¼ ë˜‘ê°™ì´ ë§ì¶”ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤

**ì´ìœ :**
1. **ì½”ë“œ ì¬ì‚¬ìš©ì„±**: `streamFetch()`, `processStream()` ë“± ê¸°ì¡´ ë¡œì§ ê·¸ëŒ€ë¡œ í™œìš©
2. **ì¼ê´€ì„±**: Backend APIì™€ ë™ì¼í•œ íŒ¨í„´ìœ¼ë¡œ ê°œë°œ/ìœ ì§€ë³´ìˆ˜ ìš©ì´
3. **í™•ì¥ì„±**: í–¥í›„ ë‹¤ë¥¸ ANTLR ì—”ë“œí¬ì¸íŠ¸ë„ ì‰½ê²Œ ìŠ¤íŠ¸ë¦¼ ì „í™˜ ê°€ëŠ¥
4. **ì‚¬ìš©ì ê²½í—˜**: ì‹¤ì‹œê°„ ì§„í–‰ ìƒí™© í‘œì‹œ ê°€ëŠ¥

### êµ¬í˜„ ìˆœì„œ

1. **ANTLR ì„œë²„ ìˆ˜ì •** (ë°±ì—”ë“œ ì‘ì—…)
   - `/antlr/parsing` ì—”ë“œí¬ì¸íŠ¸ë¥¼ NDJSON ìŠ¤íŠ¸ë¦¼ ì‘ë‹µìœ¼ë¡œ ë³€ê²½
   - ì§„í–‰ ìƒí™©ì„ ì´ë²¤íŠ¸ë¡œ ì „ì†¡

2. **í”„ë¡ íŠ¸ì—”ë“œ ìˆ˜ì •** (í˜„ì¬ ì‘ì—…)
   - `antlrApi.parseStream()` í•¨ìˆ˜ ì¶”ê°€ (ê¸°ì¡´ `streamFetch` ì¬ì‚¬ìš©)
   - `project.ts`ì˜ `parseFiles()`ë¥¼ ìŠ¤íŠ¸ë¦¼ ë°©ì‹ìœ¼ë¡œ ë³€ê²½
   - íŒŒì‹± ë©”ì‹œì§€ë¥¼ í‘œì‹œí•  UI ì¶”ê°€ (ì„ íƒì )

3. **í…ŒìŠ¤íŠ¸ ë° ê²€ì¦**
   - ìŠ¤íŠ¸ë¦¼ ë°ì´í„° ìˆ˜ì‹  í™•ì¸
   - ì—ëŸ¬ ì²˜ë¦¬ í™•ì¸
   - UI ì—…ë°ì´íŠ¸ í™•ì¸

---

## ğŸ“ ì¶”ê°€ ê³ ë ¤ì‚¬í•­

### íŒŒì‹± ë©”ì‹œì§€ ê´€ë¦¬

í˜„ì¬ `graphMessages`ì™€ `convertMessages`ê°€ ë¶„ë¦¬ë˜ì–´ ìˆë“¯ì´, íŒŒì‹± ë©”ì‹œì§€ë„ ë¶„ë¦¬ ê´€ë¦¬ ê°€ëŠ¥:

```typescript
// project.tsì— ì¶”ê°€
const parseMessages = ref<StreamMessage[]>([])

function addParseMessage(type: MessageType, content: string): void {
  parseMessages.value.push({ type, content, timestamp: createTimestamp() })
}

function clearParseMessages(): void {
  parseMessages.value = []
}
```

### UI í‘œì‹œ ìœ„ì¹˜

- ì—…ë¡œë“œ íƒ­ì—ì„œ íŒŒì‹± ë¡œê·¸ë¥¼ í‘œì‹œí• ì§€
- ê¸°ì¡´ StreamingLog ì»´í¬ë„ŒíŠ¸ ì¬ì‚¬ìš©í• ì§€
- ì•„ë‹ˆë©´ ê°„ë‹¨í•œ ìƒíƒœ ë©”ì‹œì§€ë§Œ í‘œì‹œí• ì§€ ê²°ì • í•„ìš”

